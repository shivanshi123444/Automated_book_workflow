# src/version_manager.py
import chromadb
from chromadb.utils import embedding_functions
import os
from config import CHROMADB_DATA_DIR
from typing import List, Dict, Any
import uuid
import datetime
import asyncio

# Initialize ChromaDB client. This will create/connect to a persistent ChromaDB instance.
client = chromadb.PersistentClient(path=CHROMADB_DATA_DIR)

# Define an embedding function using sentence-transformers.
# This model ('all-MiniLM-L6-v2') will be downloaded the first time it's used.
# Ensure 'sentence-transformers' is installed via requirements.txt.
sentence_transformer_ef = embedding_functions.SentenceTransformerEmbeddingFunction(model_name="all-MiniLM-L6-v2")

# Create or get the collection for book chapters.
# The embedding_function ensures that when documents are added, their embeddings
# are automatically generated and stored, enabling similarity searches.
chapters_collection = client.get_or_create_collection(
    name="book_chapters",
    embedding_function=sentence_transformer_ef
)

async def save_chapter_version(
    chapter_id: str,
    version_id: str,
    content: str,
    version_type: str, # e.g., "raw", "spun", "reviewed", "final", "human_edited"
    iteration: int,
    metadata: Dict[str, Any] = None
):
    """
    Saves a specific version of a chapter to ChromaDB.
    Each version is stored as a document with relevant metadata.
    """
    full_metadata = {
        "chapter_id": chapter_id,
        "version_id": version_id,
        "version_type": version_type,
        "iteration": iteration,
        "timestamp": datetime.datetime.now().isoformat(), # Record save time
        **(metadata if metadata else {}) # Add any additional metadata
    }
    # Create a unique document ID for ChromaDB
    doc_id = f"{chapter_id}-{version_id}-{version_type}-{iteration}"

    try:
        chapters_collection.add(
            documents=[content],
            metadatas=[full_metadata],
            ids=[doc_id],
            # embeddings are automatically generated by the collection's embedding_function
        )
        print(f"Saved version {doc_id} (Type: {version_type}) to ChromaDB.")
    except Exception as e:
        print(f"Error saving to ChromaDB: {e}")

async def get_chapter_versions(chapter_id: str = None, version_type: str = None) -> List[Dict[str, Any]]:
    """
    Retrieves chapter versions based on chapter_id and/or version_type filters.
    Returns a list of dictionaries, each containing 'id', 'content', and 'metadata'.
    """
    filters = []
    if chapter_id:
        filters.append({"chapter_id": chapter_id})
    if version_type:
        filters.append({"version_type": version_type})

    query_where = {}
    if len(filters) == 1:
        query_where = filters[0]
    elif len(filters) > 1:
        query_where = {"$and": filters}
    # If filters is empty, query_where remains empty, which means no filter is applied.

    try:
        results = chapters_collection.get(
            where=query_where if query_where else None, # Pass None if no filters, or the structured query
            # Explicitly include documents and metadatas in the results
            include=['documents', 'metadatas']
        )
        formatted_results = []
        if results and results['ids']:
            for i in range(len(results['ids'])):
                formatted_results.append({
                    "id": results['ids'][i],
                    "content": results['documents'][i],
                    "metadata": results['metadatas'][i]
                })
        return formatted_results
    except Exception as e:
        print(f"Error retrieving from ChromaDB: {e}")
        return []

async def retrieve_consistent_content_rl_search(
    chapter_id: str,
    target_version_type: str = "final",
    query_text: str = None # Could be used for semantic search in a true RL system
) -> Dict[str, Any]:
    """
    Conceptual: Implements a "RL Search Algorithm" for intelligent and consistent retrieval.
    In a full RL system, this would involve training an agent to learn the best version
    to retrieve based on a reward function (e.g., human approval, review scores).

    For this guide, we simulate an RL-like retrieval by prioritizing:
    1. The latest 'final' version.
    2. If no 'final', the 'reviewed' version with the highest combined review scores.
    3. As a fallback, the latest available version ('spun', 'human_edited', 'raw').
    """
    print(f"Attempting 'RL Search' for chapter {chapter_id} (target: {target_version_type})...")

    # 1. Prioritize retrieving 'final' versions
    final_versions = await get_chapter_versions(chapter_id=chapter_id, version_type="final")
    if final_versions:
        # If multiple 'final' versions exist, return the most recent one by timestamp
        print(f"Found {len(final_versions)} final versions. Returning the latest one.")
        final_versions.sort(key=lambda x: x['metadata'].get('timestamp', ''), reverse=True)
        return final_versions[0]

    # 2. If no 'final', look for 'reviewed' versions
    reviewed_versions = await get_chapter_versions(chapter_id=chapter_id, version_type="reviewed")
    if reviewed_versions:
        print(f"No final version found. Checking {len(reviewed_versions)} reviewed versions.")
        # Calculate a proxy score for reviewed versions based on AI review metadata
        def calculate_proxy_score(version_data):
            meta = version_data.get('metadata', {})
            # Sum of all scores, giving a higher value to better reviews
            return (meta.get('fidelity_score', 0) + meta.get('readability_score', 0) +
                    meta.get('grammar_score', 0) + meta.get('originality_score', 0))

        # Sort reviewed versions by the calculated proxy score in descending order
        reviewed_versions.sort(key=calculate_proxy_score, reverse=True)
        print(f"Returning the top-rated reviewed version.")
        return reviewed_versions[0]

    # 3. Fallback: Return the latest available version if no 'final' or 'reviewed' versions are found
    all_versions = await get_chapter_versions(chapter_id=chapter_id)
    if all_versions:
        print(f"No final or reviewed version found. Falling back to the latest available version.")
        all_versions.sort(key=lambda x: x['metadata'].get('timestamp', ''), reverse=True)
        return all_versions[0]

    print(f"No versions found for chapter {chapter_id} in ChromaDB.")
    return {} # Return an empty dict if no versions are found

# Example usage for testing this module independently
async def main_versioning_test():
    # It's good practice to ensure a clean state for isolated tests
    try:
        # Delete the collection to ensure a fresh start for the test
        client.delete_collection(name="book_chapters")
        # Re-create the collection after deletion
        global chapters_collection
        chapters_collection = client.get_or_create_collection(
            name="book_chapters",
            embedding_function=sentence_transformer_ef
        )
        print("ChromaDB collection 'book_chapters' reset for testing.")
    except Exception as e:
        print(f"Could not reset ChromaDB collection for testing (might not exist yet): {e}")


    chapter_id = "test_chapter_for_versioning"

    # Add various versions for testing retrieval logic
    await save_chapter_version(chapter_id, str(uuid.uuid4()), "This is the raw content.", "raw", 0)
    await asyncio.sleep(0.01) # Small delay for distinct timestamps
    await save_chapter_version(chapter_id, str(uuid.uuid4()), "Spun content, first draft.", "spun", 1)
    await asyncio.sleep(0.01)
    await save_chapter_version(chapter_id, str(uuid.uuid4()), "Reviewed content, feedback applied.", "reviewed", 1,
                               metadata={"fidelity_score": 7, "readability_score": 8, "grammar_score": 7, "originality_score": 6})
    await asyncio.sleep(0.01)
    await save_chapter_version(chapter_id, str(uuid.uuid4()), "Human edited version of draft.", "human_edited", 1)
    await asyncio.sleep(0.01)
    await save_chapter_version(chapter_id, str(uuid.uuid4()), "Spun content, second draft.", "spun", 2)
    await asyncio.sleep(0.01)
    await save_chapter_version(chapter_id, str(uuid.uuid4()), "Reviewed content, second draft, good scores.", "reviewed", 2,
                               metadata={"fidelity_score": 9, "readability_score": 9, "grammar_score": 9, "originality_score": 8})
    await asyncio.sleep(0.01)
    final_version_content = "This is the approved and finalized chapter content."
    await save_chapter_version(chapter_id, str(uuid.uuid4()), final_version_content, "final", 3)


    print("\n--- Retrieving All Versions for Test Chapter ---")
    all_ch_versions = await get_chapter_versions(chapter_id=chapter_id)
    for v in all_ch_versions:
        print(f"ID: {v['id']}, Type: {v['metadata']['version_type']}, Iter: {v['metadata']['iteration']}, Content Sample: {v['content'][:50]}...")

    print("\n--- Retrieving Final Version using RL Search (Expected: 'final') ---")
    retrieved_final = await retrieve_consistent_content_rl_search(chapter_id)
    if retrieved_final:
        print(f"Retrieved: ID: {retrieved_final['id']}, Type: {retrieved_final['metadata']['version_type']}, Content: {retrieved_final['content']}")
    else:
        print(f"Failed to retrieve final version for {chapter_id}")


    print("\n--- Testing Retrieval without 'final' version (Expected: Best 'reviewed') ---")
    chapter_id_no_final = "test_chapter_no_final"
    # Ensure this separate test chapter also starts clean
    try:
        client.delete_collection(name="book_chapters_no_final_test")
        global chapters_collection_no_final_test
        chapters_collection_no_final_test = client.get_or_create_collection(
            name="book_chapters_no_final_test",
            embedding_function=sentence_transformer_ef
        )
        print("ChromaDB collection 'book_chapters_no_final_test' reset for testing.")
    except Exception as e:
        print(f"Could not reset ChromaDB collection for no final test (might not exist yet): {e}")


    await save_chapter_version(chapter_id_no_final, str(uuid.uuid4()), "Spun content for no final test.", "spun", 1)
    await asyncio.sleep(0.01)
    await save_chapter_version(chapter_id_no_final, str(uuid.uuid4()), "Reviewed (score 25) for no final test.", "reviewed", 1,
                               metadata={"fidelity_score": 6, "readability_score": 7, "grammar_score": 6, "originality_score": 6})
    await asyncio.sleep(0.01)
    await save_chapter_version(chapter_id_no_final, str(uuid.uuid4()), "Reviewed (score 36) for no final test (better).", "reviewed", 2,
                               metadata={"fidelity_score": 9, "readability_score": 9, "grammar_score": 9, "originality_score": 9})

    best_reviewed_content = await retrieve_consistent_content_rl_search(chapter_id_no_final)
    if best_reviewed_content:
        print(f"Retrieved: ID: {best_reviewed_content['id']}, Type: {best_reviewed_content['metadata']['version_type']}, Content: {best_reviewed_content['content']}")
    else:
        print(f"Failed to retrieve best reviewed version for {chapter_id_no_final}")


if __name__ == "__main__":
    asyncio.run(main_versioning_test())
